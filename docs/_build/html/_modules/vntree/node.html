
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>vntree.node &#8212; vntree  documentation</title>
    <link rel="stylesheet" href="../../_static/better.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  </head><body>
    <header id="pageheader"><h1><a href="../../index.html ">
        vntree  documentation
    </a></h1></header>
  <div class="related top">
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
  <nav id="breadcrumbs">
    <ul>
      <li><a href="../../index.html">vntree  documentation</a></li>
      <li>
        <a href="../index.html">Module code</a>
      </li> 
    </ul>
  </nav>
  </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for vntree.node</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Copyright © 2018-2019 Stephen McEntee</span>
<span class="sd">Licensed under the MIT license. </span>
<span class="sd">See «vn-tree» LICENSE file for details https://github.com/qwilka/vn-tree/blob/master/LICENSE</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c1">#import collections</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">difflib</span> <span class="k">import</span> <span class="n">SequenceMatcher</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">pathlib</span> 
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">textwrap</span>


<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">yaml</span>
    <span class="n">yaml_imported</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">except</span> <span class="ne">ImportError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;PyYAML not installed (see https://pyyaml.org/); </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">err</span><span class="p">,)</span> <span class="p">)</span>
    <span class="n">yaml_imported</span> <span class="o">=</span> <span class="kc">False</span>


<div class="viewcode-block" id="NodeAttr"><a class="viewcode-back" href="../../api.html#vntree.NodeAttr">[docs]</a><span class="k">class</span> <span class="nc">NodeAttr</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Descriptor class for node attributes. </span>
<span class="sd">    </span>
<span class="sd">    NodeAttr attributes are stored in the node instance `data` dictionary. </span>
<span class="sd">    This facilitates serialization and persistance of the tree.</span>

<span class="sd">    :param ns: namespace for storing attribute in a nested dictionary in `data`.</span>
<span class="sd">                `ns=None` for top-level attributes.</span>
<span class="sd">    :type ns: str or None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">initial</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ns</span> <span class="o">=</span> <span class="n">ns</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initial</span> <span class="o">=</span> <span class="n">initial</span>  
    <span class="k">def</span> <span class="nf">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">owner</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ns</span> <span class="ow">in</span> <span class="n">instance</span><span class="o">.</span><span class="n">data</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">instance</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ns</span><span class="p">],</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">_value</span> <span class="o">=</span> <span class="n">instance</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ns</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#logger.error(&quot;%s.__get__ «%s»; ns «%s» not in %s&quot; % (self.__class__.__name__, self.name, self.ns, instance))</span>
            <span class="n">_value</span> <span class="o">=</span> <span class="n">instance</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_value</span>
    <span class="k">def</span> <span class="nf">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ns</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ns</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">instance</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
                <span class="n">instance</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ns</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">instance</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ns</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">instance</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">def</span> <span class="nf">__delete__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ns</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">instance</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ns</span><span class="p">]:</span>
            <span class="k">del</span> <span class="n">instance</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ns</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">instance</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">instance</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
    <span class="k">def</span> <span class="nf">__set_name__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">owner</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span></div>


<div class="viewcode-block" id="TreeAttr"><a class="viewcode-back" href="../../api.html#vntree.TreeAttr">[docs]</a><span class="k">class</span> <span class="nc">TreeAttr</span><span class="p">(</span><span class="n">NodeAttr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Descriptor class for tree attributes.  `TreeAttr` attribute </span>
<span class="sd">    values are stored in the root node `data` dictionary. </span>
<span class="sd">    </span>
<span class="sd">    Storing an attribute in the root node of the tree ensures that the</span>
<span class="sd">    attribute can be found by all nodes in the tree. </span>
<span class="sd">    `TreeAttr` is a subclass of `NodeAttr`.</span>

<span class="sd">    :param ns: namespace for attribute. `ns=None` for top-level attributes.</span>
<span class="sd">    :type ns: str or None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ns</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">ns</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">owner</span><span class="p">):</span>
        <span class="n">_value</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__get__</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">owner</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">_value</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">instance</span><span class="o">.</span><span class="n">parent</span><span class="p">:</span>
            <span class="n">_value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">instance</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_value</span>
    <span class="k">def</span> <span class="nf">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">instance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">instance</span><span class="o">.</span><span class="n">_root</span><span class="p">:</span> <span class="c1">#if instance is not instance.get_rootnode():</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.__set__: non-root node «</span><span class="si">%s</span><span class="s2">» set value «</span><span class="si">%s</span><span class="s2">»=«</span><span class="si">%s</span><span class="s2">»&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">instance</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__set__</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span></div>



<div class="viewcode-block" id="Node"><a class="viewcode-back" href="../../api.html#vntree.Node">[docs]</a><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Class for creating vntree nodes.</span>

<span class="sd">    :param name: node name</span>
<span class="sd">    :type name: str or None</span>
<span class="sd">    :param parent: The parent node of this node.</span>
<span class="sd">    :type parent: Node or None</span>
<span class="sd">    :param data: Dictionary containing node data.</span>
<span class="sd">    :type data: dict or None</span>
<span class="sd">    :param treedict: Dictionary specifying a complete tree.</span>
<span class="sd">    :type treedict: dict or None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">YAML_setup</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">NodeAttr</span><span class="p">()</span>
    <span class="n">_vnpkl_fpath</span> <span class="o">=</span> <span class="n">TreeAttr</span><span class="p">(</span><span class="s2">&quot;_vntree_meta&quot;</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                <span class="n">treedict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vnpkl_fpath</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="c1">#self.data = collections.defaultdict(dict, copy.deepcopy(data))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">name</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">childs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">parent</span> <span class="ow">and</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">parent</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">Node</span><span class="p">):</span>
            <span class="n">parent</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">parent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">.__init__: instance «</span><span class="si">{}</span><span class="s2">» argument «parent» type not valid: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">parent</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">name</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">treedict</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">treedict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">from_treedict</span><span class="p">(</span><span class="n">treedict</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">vnpkl_fpath</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vnpkl_fpath</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_vnpkl_fpath</span> <span class="o">=</span> <span class="n">vnpkl_fpath</span>


    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> coord=</span><span class="si">{}</span><span class="s2"> «</span><span class="si">{}</span><span class="s2">»&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coord</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> 
        <span class="k">yield</span> <span class="bp">self</span>  
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="nb">map</span><span class="p">(</span><span class="nb">iter</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">childs</span><span class="p">)):</span>
            <span class="k">yield</span> <span class="n">node</span>


    <span class="k">def</span> <span class="nf">__reversed__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="nb">map</span><span class="p">(</span><span class="nb">reversed</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">childs</span><span class="p">)):</span>
            <span class="k">yield</span> <span class="n">node</span>
        <span class="k">yield</span> <span class="bp">self</span> 


<div class="viewcode-block" id="Node.add_child"><a class="viewcode-back" href="../../api.html#vntree.Node.add_child">[docs]</a>    <span class="k">def</span> <span class="nf">add_child</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a child node to the current node instance.</span>

<span class="sd">        :param node: the child node instance.</span>
<span class="sd">        :type node: Node</span>
<span class="sd">        :returns: The new child node instance.   </span>
<span class="sd">        :rtype: Node </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">Node</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">.add_child: arg «node»=«</span><span class="si">{}</span><span class="s2">», type </span><span class="si">{}</span><span class="s2"> not valid.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">node</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">childs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="n">node</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">node</span>    </div>

<div class="viewcode-block" id="Node.copy"><a class="viewcode-back" href="../../api.html#vntree.Node.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a deep copy of the sub-tree rooted at this node instance.</span>

<span class="sd">        :returns: Copy of the sub-tree rooted at this node instance.</span>
<span class="sd">        :rtype: Node </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="Node.remove_child"><a class="viewcode-back" href="../../api.html#vntree.Node.remove_child">[docs]</a>    <span class="k">def</span> <span class="nf">remove_child</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">node</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove a child node from the current node instance.</span>

<span class="sd">        :param idx: Index of child node to be removed.</span>
<span class="sd">        :type idx: int </span>
<span class="sd">        :param name: The first child node found with «name» will be removed. </span>
<span class="sd">        :type name: str</span>
<span class="sd">        :param node: Child node to be removed.</span>
<span class="sd">        :type node: Node </span>
<span class="sd">        :returns: The node that has been removed, or False if not successful.</span>
<span class="sd">        :rtype: Node or False </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> 
            <span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">childs</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">childs</span><span class="p">)</span> <span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">childs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">found_node</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">_n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">childs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">_n</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">name</span><span class="p">:</span>
                    <span class="n">found_node</span> <span class="o">=</span> <span class="n">_n</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">found_node</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">childs</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">found_node</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">found_node</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">and</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">childs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">childs</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">node</span>
        <span class="k">return</span> <span class="kc">False</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_path</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Attribute indicating the absolute node path for this node. </span>
<span class="sd">        </span>
<span class="sd">        Note that the absolute node path starts with a forward slash </span>
<span class="sd">        followed by the root node&#39;s name: e.g: </span>
<span class="sd">        `/root.name/child.name/grandchild.name`</span>
<span class="sd">        Warning: it should be noted that use of _path assumes  </span>
<span class="sd">        that sibling nodes have unique names. If unique node paths</span>
<span class="sd">        cannot be assured, use node attribute «_coord» instead.</span>

<span class="sd">        :returns: The absolute node path for this node.</span>
<span class="sd">        :rtype: str </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_path</span> <span class="o">=</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">PurePosixPath</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="n">_node</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">while</span> <span class="n">_node</span><span class="o">.</span><span class="n">parent</span><span class="p">:</span>
            <span class="n">_path</span> <span class="o">=</span> <span class="n">_node</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span> <span class="o">/</span> <span class="n">_path</span>
            <span class="n">_node</span> <span class="o">=</span> <span class="n">_node</span><span class="o">.</span><span class="n">parent</span>
        <span class="n">_path</span> <span class="o">=</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">posixpath</span><span class="o">.</span><span class="n">sep</span> <span class="o">/</span> <span class="n">_path</span>
        <span class="k">return</span> <span class="n">_path</span><span class="o">.</span><span class="n">as_posix</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_coord</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Attribute indicating the tree coordinates for this node.</span>

<span class="sd">        The tree coordinates of a node are expressed as a tuple of the</span>
<span class="sd">        indices of the node and its ancestors, for example:</span>
<span class="sd">        A grandchild node with node path </span>
<span class="sd">        `/root.name/root.childs[2].name/root.childs[2].childs[0].name` </span>
<span class="sd">        would have coordinates `(2,0)`.</span>
<span class="sd">        The root node _coord is an empty tuple: `()`</span>

<span class="sd">        :returns: the tree coordinates for this node.</span>
<span class="sd">        :rtype: tuple </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_coord</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">_node</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">while</span> <span class="n">_node</span><span class="o">.</span><span class="n">parent</span><span class="p">:</span>
            <span class="n">_idx</span> <span class="o">=</span> <span class="n">_node</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">childs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">_node</span><span class="p">)</span>
            <span class="n">_coord</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">_idx</span><span class="p">)</span>
            <span class="n">_node</span> <span class="o">=</span> <span class="n">_node</span><span class="o">.</span><span class="n">parent</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_coord</span><span class="p">)</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_level</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Attribute indicating the tree `level` for this node instance.</span>

<span class="sd">        Note that the root node is defined as level 1.</span>

<span class="sd">        :returns: the node `level`.</span>
<span class="sd">        :rtype: int </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_coord</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>


<div class="viewcode-block" id="Node.get_data"><a class="viewcode-back" href="../../api.html#vntree.Node.get_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">keys</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a value from the instance `data` dict. </span>

<span class="sd">        Nested values are accessed by specifying the keys in sequence. </span>
<span class="sd">        e.g. `node.get_data(&quot;country&quot;, &quot;city&quot;)` would access</span>
<span class="sd">        `node.data[&quot;country&quot;][&quot;city&quot;]`</span>

<span class="sd">        :param keys: the `data` dict keys referencing the required value.</span>
<span class="sd">        :type keys: str </span>
<span class="sd">        :returns: the value accessed by `keys` in `data`. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">keys</span><span class="p">:</span>
            <span class="n">_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
        <span class="n">_datadict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
        <span class="k">for</span> <span class="n">_key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
            <span class="n">_val</span> <span class="o">=</span> <span class="n">_datadict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">_key</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_val</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">_datadict</span> <span class="o">=</span> <span class="n">_val</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_val</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">_val</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">_val</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_val</span></div>


<div class="viewcode-block" id="Node.set_data"><a class="viewcode-back" href="../../api.html#vntree.Node.set_data">[docs]</a>    <span class="k">def</span> <span class="nf">set_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">keys</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set a value in the instance `data` dict.</span>

<span class="sd">        :param keys: the `data` dict keys referencing the value in the `data` dict.</span>
<span class="sd">        :type keys: str </span>
<span class="sd">        :param value: the value to be set in the `data` dict. Note that</span>
<span class="sd">            `value` is a keyword-only argument.</span>
<span class="sd">        :returns: `True` if successful. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_datadict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">_key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">keys</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ii</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">_datadict</span><span class="p">[</span><span class="n">_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># if _key not in _datadict:</span>
                <span class="c1">#     _datadict[_key] = {}</span>
                <span class="c1"># _datadict = _datadict[_key]</span>
                <span class="n">_datadict</span> <span class="o">=</span> <span class="n">_datadict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">_key</span><span class="p">,</span> <span class="p">{})</span>
        <span class="k">return</span> <span class="kc">True</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_root</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Attribute referencing the root node of the tree.</span>

<span class="sd">        :returns: the root node of the tree containing this instance.</span>
<span class="sd">        :rtype: Node</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_n</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">while</span> <span class="n">_n</span><span class="o">.</span><span class="n">parent</span><span class="p">:</span>
            <span class="n">_n</span> <span class="o">=</span> <span class="n">_n</span><span class="o">.</span><span class="n">parent</span>
        <span class="k">return</span> <span class="n">_n</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_ancestors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Attribute referencing the tree ancestors of the node instance.</span>

<span class="sd">        :returns: list of node ancestors in sequence, first item is </span>
<span class="sd">            the current node instance (`self`), the last item is root.</span>
<span class="sd">        :rtype: list of Node references</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># return list of ancestor nodes starting with self.parent and ending with root</span>
        <span class="n">_ancestors</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">_n</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">while</span> <span class="n">_n</span><span class="o">.</span><span class="n">parent</span><span class="p">:</span>
            <span class="n">_n</span> <span class="o">=</span> <span class="n">_n</span><span class="o">.</span><span class="n">parent</span>
            <span class="n">_ancestors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_n</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_ancestors</span>


<div class="viewcode-block" id="Node.get_child_by_name"><a class="viewcode-back" href="../../api.html#vntree.Node.get_child_by_name">[docs]</a>    <span class="k">def</span> <span class="nf">get_child_by_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">childname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a child node of the current instance by its name.</span>

<span class="sd">        :param childname: the name of the required child node.</span>
<span class="sd">        :type childname: str</span>
<span class="sd">        :returns: the first child node found with name `childname`.</span>
<span class="sd">        :rtype: Node or None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_childs</span> <span class="o">=</span> <span class="p">[</span><span class="n">_child</span> <span class="k">for</span> <span class="n">_child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">childs</span> <span class="k">if</span> <span class="n">_child</span><span class="o">.</span><span class="n">name</span><span class="o">==</span><span class="n">childname</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">_childs</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.get_child_by_name: node:«</span><span class="si">%s</span><span class="s2">» has more than 1 childnode with name=«</span><span class="si">%s</span><span class="s2">».&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">childname</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">_childs</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">_childnode</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_childnode</span> <span class="o">=</span> <span class="n">_childs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> 
        <span class="k">return</span> <span class="n">_childnode</span></div>


<div class="viewcode-block" id="Node.get_node_by_path"><a class="viewcode-back" href="../../api.html#vntree.Node.get_node_by_path">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_by_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a node from a node path. </span>

<span class="sd">        Warning: use of this method assumes that sibling nodes have unique names,</span>
<span class="sd">        if this is not assured the `get_node_by_coord` method can be used instead.</span>

<span class="sd">        |  Example with absolute node path: </span>
<span class="sd">        |  `node.get_node_by_path(&#39;/root.name/child.name/gchild.name&#39;)`</span>
<span class="sd">        |  Example with relative node path:</span>
<span class="sd">        |  `node.get_node_by_path(&#39;child.name/gchild.name&#39;)`</span>

<span class="sd">        :param path: the absolute node path, or the node path relative </span>
<span class="sd">            to the current node instance.</span>
<span class="sd">        :type path: str</span>
<span class="sd">        :returns: the node corresponding to `path`.</span>
<span class="sd">        :rtype: Node or None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">path</span><span class="o">==</span><span class="s2">&quot;.&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="n">path</span><span class="o">.</span><span class="n">lstrip</span><span class="p">()</span><span class="o">.</span><span class="n">startswith</span><span class="p">((</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="s2">&quot;./&quot;</span><span class="p">))</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.get_node_by_path: arg «path»=«</span><span class="si">%s</span><span class="s2">», not correctly specified.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">path</span><span class="p">))</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">_pathlist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">))</span> <span class="p">)</span> <span class="c1"># remove blank strings</span>
        <span class="k">if</span> <span class="n">path</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">):</span>
            <span class="n">_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_root</span>  
            <span class="n">_pathlist</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># remove rootnode name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_node</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">_nodename</span> <span class="ow">in</span> <span class="n">_pathlist</span><span class="p">:</span>
            <span class="n">_node</span> <span class="o">=</span> <span class="n">_node</span><span class="o">.</span><span class="n">get_child_by_name</span><span class="p">(</span><span class="n">_nodename</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.get_node_by_path: node«</span><span class="si">%s</span><span class="s2">», arg `path`=«</span><span class="si">%s</span><span class="s2">», cannot find node.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">path</span><span class="p">))</span>
                <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">_node</span></div>


<div class="viewcode-block" id="Node.get_node_by_coord"><a class="viewcode-back" href="../../api.html#vntree.Node.get_node_by_coord">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_by_coord</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coord</span><span class="p">,</span> <span class="n">relative</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a node from a node coord. </span>

<span class="sd">        :param coord: the coordinates of the required node.</span>
<span class="sd">        :type coord: tuple or list</span>
<span class="sd">        :param relative: `True` if coord is relative to the node instance,</span>
<span class="sd">            `False` for absolute coordinates.</span>
<span class="sd">        :type relative: bool</span>
<span class="sd">        :returns: the node corresponding to `coord`.</span>
<span class="sd">        :rtype: Node or None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">or</span> <span class="kc">False</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="nb">type</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">==</span><span class="nb">int</span><span class="p">,</span> <span class="n">coord</span><span class="p">)):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.get_node_by_coord: node«</span><span class="si">%s</span><span class="s2">», arg «coord»=«</span><span class="si">%s</span><span class="s2">», «coord» must be list or tuple of integers.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">coord</span><span class="p">))</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">relative</span><span class="p">:</span>
            <span class="n">_node</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_root</span> <span class="c1"># _node = self.get_rootnode()</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">coord</span><span class="p">:</span>
            <span class="n">_node</span> <span class="o">=</span> <span class="n">_node</span><span class="o">.</span><span class="n">childs</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.get_node_by_coord: node«</span><span class="si">%s</span><span class="s2">», arg «coord»=«</span><span class="si">%s</span><span class="s2">» not valid.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">coord</span><span class="p">))</span>
                <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">_node</span></div>


<div class="viewcode-block" id="Node.find_one_node"><a class="viewcode-back" href="../../api.html#vntree.Node.find_one_node">[docs]</a>    <span class="k">def</span> <span class="nf">find_one_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">keys</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">decend</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find a node on the branch of the instance with a</span>
<span class="sd">        `keys=data` item in the `data` dict. </span>

<span class="sd">        Nested values are accessed by specifying the keys in sequence. </span>
<span class="sd">        e.g. `node.get_data(&quot;country&quot;, &quot;city&quot;)` would access</span>
<span class="sd">        `node.data[&quot;country&quot;][&quot;city&quot;]`</span>

<span class="sd">        :param keys: the `data` dict key(s) referencing the required value.</span>
<span class="sd">        :type keys: str </span>
<span class="sd">        :param value: the value corresponding to `keys`. Note that</span>
<span class="sd">            `value` is a keyword-only argument.</span>
<span class="sd">        :param decend: `decend=True` traverse down the branch sub-tree  </span>
<span class="sd">            starting from `self`. `decend=False` traverse up the   </span>
<span class="sd">            branch from `self` towards root.</span>
<span class="sd">        :type decend: bool </span>
<span class="sd">        :returns: the first node found with `keys=data` in the `data` dict. </span>
<span class="sd">        :rtype: Node or None </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">decend</span><span class="p">:</span>
            <span class="n">traversal</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">traversal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ancestors</span>
        <span class="k">for</span> <span class="n">_node</span> <span class="ow">in</span> <span class="n">traversal</span><span class="p">:</span>
            <span class="n">_val</span> <span class="o">=</span> <span class="n">_node</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span><span class="o">*</span><span class="n">keys</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">_val</span> <span class="o">==</span> <span class="n">value</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">_node</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Node.to_texttree"><a class="viewcode-back" href="../../api.html#vntree.Node.to_texttree">[docs]</a>    <span class="k">def</span> <span class="nf">to_texttree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">symbol</span><span class="o">=</span><span class="s1">&#39;ascii&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method returning a text representation of the (sub-)tree  </span>
<span class="sd">        rooted at the current node instance (`self`).</span>

<span class="sd">        :param indent: the indentation width for each tree level.</span>
<span class="sd">        :type indent: int</span>
<span class="sd">        :param func: function returning a string representation for </span>
<span class="sd">            each node. e.g. `func=lambda n: str(n._coord)`</span>
<span class="sd">            would show the node coordinates. </span>
<span class="sd">            `func=True` node.name displayed for each node. </span>
<span class="sd">            `func=False` no node representation, just</span>
<span class="sd">            the tree structure is displayed.</span>
<span class="sd">        :type func: function or bool</span>
<span class="sd">        :param symbol: tuple of tree symbol characters.</span>
<span class="sd">            `None` or &#39;ascii&#39; gives a preformed ascii tree, equivalent to tuple :code:`(|, +, |, |, |, -, .)`.</span>
<span class="sd">            &#39;box&#39; preformed with box-drawing characters, equivalent to tuple :code:`(┬, └, ┬, ├, └, ─, ⋅)`.</span>
<span class="sd">            &#39;unicode&#39; preformed with unicode characters.</span>
<span class="sd">        :type symbol: tuple or str or None</span>
<span class="sd">        :returns: a string representation of the tree.</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">indent</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">:</span>
            <span class="n">indent</span><span class="o">=</span><span class="mi">2</span>
        <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>  <span class="c1"># default func prints node.name</span>
            <span class="n">func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="s2">&quot; </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">s_root</span><span class="p">,</span> <span class="n">s_branch</span><span class="p">,</span> <span class="n">s_spar</span><span class="p">,</span> <span class="n">s_fnode</span>  <span class="o">=</span> <span class="n">symbol</span>
        <span class="k">elif</span> <span class="n">symbol</span><span class="o">==</span><span class="s2">&quot;unicode&quot;</span><span class="p">:</span>
            <span class="c1"># ┬ └ ┬ ├ └ ─ ⋅</span>
            <span class="n">s_root</span><span class="p">,</span> <span class="n">s_branch</span><span class="p">,</span> <span class="n">s_fnode</span><span class="p">,</span> <span class="n">s_mnode</span><span class="p">,</span> <span class="n">s_lnode</span><span class="p">,</span> <span class="n">s_spar</span><span class="p">,</span> <span class="n">s_level</span>  <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;</span><span class="se">\u252c</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\u2514</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\u252c</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\u251c</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\u2514</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\u2500</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\u22c5</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">symbol</span><span class="o">==</span><span class="s2">&quot;box&quot;</span><span class="p">:</span> <span class="c1"># https://en.wikipedia.org/wiki/Box-drawing_character</span>
            <span class="c1"># ┬ └ ┬ ├ └ ─ ⋅</span>
            <span class="n">s_root</span><span class="p">,</span> <span class="n">s_branch</span><span class="p">,</span> <span class="n">s_fnode</span><span class="p">,</span> <span class="n">s_mnode</span><span class="p">,</span> <span class="n">s_lnode</span><span class="p">,</span> <span class="n">s_spar</span><span class="p">,</span> <span class="n">s_level</span>  <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;</span><span class="se">\u252c</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\u2514</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\u252c</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\u251c</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\u2514</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\u2500</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\u22c5</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">s_root</span><span class="p">,</span> <span class="n">s_branch</span><span class="p">,</span> <span class="n">s_fnode</span><span class="p">,</span> <span class="n">s_mnode</span><span class="p">,</span> <span class="n">s_lnode</span><span class="p">,</span> <span class="n">s_spar</span><span class="p">,</span> <span class="n">s_level</span>  <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;|&quot;</span><span class="p">,</span> <span class="s2">&quot;+&quot;</span><span class="p">,</span> <span class="s2">&quot;|&quot;</span><span class="p">,</span> <span class="s2">&quot;|&quot;</span><span class="p">,</span> <span class="s2">&quot;|&quot;</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="s2">&quot;.&quot;</span><span class="p">)</span>
        <span class="n">_text</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="c1">#local_root_level = len(self.ancestors)</span>
        <span class="n">local_root_level</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_level</span> 
        <span class="k">for</span> <span class="n">_n</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span> 
            <span class="c1">#level = len(node.ancestors) - local_root_level</span>
            <span class="n">level</span> <span class="o">=</span> <span class="n">_n</span><span class="o">.</span><span class="n">_level</span> <span class="o">-</span> <span class="n">local_root_level</span>
            <span class="k">if</span> <span class="n">level</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">_text</span> <span class="o">+=</span> <span class="n">s_root</span>
            <span class="c1">#elif _n.parent.childs[0] == _n and len(_n.parent.childs)&gt;1:   # first child</span>
            <span class="k">elif</span> <span class="n">_n</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">childs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">_n</span><span class="p">:</span>
                <span class="c1">#s_spar=&quot;f&quot;</span>
                <span class="n">_text</span> <span class="o">+=</span> <span class="p">(</span>  <span class="p">(</span><span class="n">s_level</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span><span class="o">*</span><span class="p">(</span><span class="n">indent</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="n">level</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> 
                            <span class="o">+</span> <span class="n">s_branch</span> 
                            <span class="o">+</span> <span class="n">s_spar</span><span class="o">*</span><span class="p">(</span><span class="n">indent</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> 
                            <span class="o">+</span> <span class="n">s_fnode</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">_n</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">childs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">_n</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">_n</span><span class="o">.</span><span class="n">childs</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>   <span class="c1"># last child, no children</span>
                <span class="c1">#s_spar=&quot;l&quot;</span>
                <span class="n">_text</span> <span class="o">+=</span> <span class="p">(</span> <span class="p">(</span><span class="n">s_level</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span><span class="o">*</span><span class="p">(</span><span class="n">indent</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="n">level</span><span class="p">)</span> 
                            <span class="o">+</span> <span class="n">s_lnode</span> <span class="p">)</span>
            <span class="k">elif</span> <span class="n">_n</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">childs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">_n</span><span class="p">:</span>   <span class="c1"># last child, has children</span>
                <span class="c1">#s_spar=&quot;l&quot;</span>
                <span class="n">_text</span> <span class="o">+=</span> <span class="p">(</span> <span class="p">(</span><span class="n">s_level</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span><span class="o">*</span><span class="p">(</span><span class="n">indent</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="n">level</span><span class="p">)</span> 
                            <span class="o">+</span> <span class="n">s_mnode</span> <span class="p">)</span>
                            <span class="c1">#+ s_spar*(indent-1) )</span>
            <span class="c1"># elif level&gt;0:</span>
            <span class="c1">#     _text += (s_level + &quot; &quot;*(indent-1))*(level-1) + s_branch + s_spar*(indent-1)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1">#_text += s_fnode</span>
                <span class="c1">#s_spar=&quot;m&quot;</span>
                <span class="n">_text</span> <span class="o">+=</span> <span class="p">(</span> <span class="p">(</span><span class="n">s_level</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span><span class="o">*</span><span class="p">(</span><span class="n">indent</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="n">level</span><span class="p">)</span> 
                            <span class="o">+</span> <span class="n">s_mnode</span> <span class="p">)</span>
                            <span class="c1">#+ s_spar*(indent-1) )</span>
            <span class="k">if</span> <span class="n">func</span> <span class="ow">and</span> <span class="n">callable</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
                <span class="n">_text</span> <span class="o">+=</span> <span class="n">func</span><span class="p">(</span><span class="n">_n</span><span class="p">)</span>
            <span class="n">_text</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="n">_text</span></div>


    <span class="k">def</span> <span class="nf">from_treedict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">treedict</span><span class="p">):</span>
        <span class="k">if</span> <span class="s2">&quot;data&quot;</span> <span class="ow">in</span> <span class="n">treedict</span><span class="p">:</span>
            <span class="c1">#self.data = collections.defaultdict(dict, treedict[&quot;data&quot;])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">treedict</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">treedict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;parent&quot;</span><span class="p">,</span> <span class="s2">&quot;childs&quot;</span><span class="p">,</span> <span class="s2">&quot;data&quot;</span><span class="p">]:</span>
                <span class="k">continue</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;childs&quot;</span> <span class="ow">in</span> <span class="n">treedict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">_childdict</span> <span class="ow">in</span> <span class="n">treedict</span><span class="p">[</span><span class="s2">&quot;childs&quot;</span><span class="p">]:</span>
                <span class="c1">#self.childs.append( self.__class__(parent=self, treedict=_childdict) )</span>
                <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">parent</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">treedict</span><span class="o">=</span><span class="n">_childdict</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_treedict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">vntree_meta</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="c1"># NOTE: replace vars(self) with self.__dict__ ( and self.__class__.__dict__ ?)</span>
        <span class="n">_dct</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;parent&quot;</span><span class="p">,</span> <span class="s2">&quot;childs&quot;</span><span class="p">]}</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">vntree_meta</span> <span class="ow">and</span> <span class="s2">&quot;_vntree_meta&quot;</span> <span class="ow">in</span> <span class="n">_dct</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">]:</span>
            <span class="n">_dct</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;_vntree_meta&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">recursive</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">childs</span><span class="p">:</span>
            <span class="n">_dct</span><span class="p">[</span><span class="s2">&quot;childs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">_child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">childs</span><span class="p">:</span>
                <span class="n">_dct</span><span class="p">[</span><span class="s2">&quot;childs&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">_child</span><span class="o">.</span><span class="n">to_treedict</span><span class="p">(</span><span class="n">recursive</span><span class="o">=</span><span class="n">recursive</span><span class="p">)</span> <span class="p">)</span>
        <span class="k">return</span> <span class="n">_dct</span> 

    <span class="k">def</span> <span class="nf">to_json</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filepath</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="nb">str</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="c1"># def from_json(self, filepath):</span>
    <span class="c1">#     err = &quot;&quot;</span>
    <span class="c1">#     _treedict = None</span>
    <span class="c1">#     if isinstance(filepath, str) and os.path.isfile(filepath):</span>
    <span class="c1">#         try:</span>
    <span class="c1">#             with open(filepath, &#39;r&#39;) as _fh:</span>
    <span class="c1">#                 _treedict = json.load(_fh)</span>
    <span class="c1">#         except Exception as err: </span>
    <span class="c1">#             pass</span>
    <span class="c1">#     if not _treedict:</span>
    <span class="c1">#         logger.warning(&quot;%s.from_json: node«%s», cannot open «filepath»=«%s», %s.&quot; % (self.__class__.__name__, self.name, filepath, err))</span>
    <span class="c1">#         return False</span>
    <span class="c1">#     else:</span>
    <span class="c1">#         self.from_treedict(treedict=_treedict)</span>
    <span class="c1">#         return True</span>

<div class="viewcode-block" id="Node.tree_compare"><a class="viewcode-back" href="../../api.html#vntree.Node.tree_compare">[docs]</a>    <span class="k">def</span> <span class="nf">tree_compare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">othertree</span><span class="p">,</span> <span class="n">vntree_meta</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compare the (sub-)tree rooted at `self` with another tree.</span>

<span class="sd">        `tree_compare` converts the trees being compared into JSON string</span>
<span class="sd">        representations, and uses `difflib.SequenceMatcher().ratio()` to</span>
<span class="sd">        calculate a measure of the similarity of the strings.</span>

<span class="sd">        :param othertree: the other tree for comparison.</span>
<span class="sd">        :type othertree: Node</span>
<span class="sd">        :param vntree_meta: include private vntree metadata in comparison.</span>
<span class="sd">        :type vntree_meta: bool</span>
<span class="sd">        :returns: similarity of the trees as a number between 0 and 1. </span>
<span class="sd">        :rtype: float </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SequenceMatcher</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> 
                <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_treedict</span><span class="p">(</span><span class="n">vntree_meta</span><span class="o">=</span><span class="n">vntree_meta</span><span class="p">),</span> <span class="n">default</span><span class="o">=</span><span class="nb">str</span><span class="p">),</span> 
                <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">othertree</span><span class="o">.</span><span class="n">to_treedict</span><span class="p">(</span><span class="n">vntree_meta</span><span class="o">=</span><span class="n">vntree_meta</span><span class="p">),</span> <span class="n">default</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
                <span class="p">)</span><span class="o">.</span><span class="n">ratio</span><span class="p">()</span></div>


<div class="viewcode-block" id="Node.savefile"><a class="viewcode-back" href="../../api.html#vntree.Node.savefile">[docs]</a>    <span class="k">def</span> <span class="nf">savefile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filepath</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Save (dump) the tree in a pickle file.</span>

<span class="sd">        Note that this method saves the complete tree even when invoked on</span>
<span class="sd">        a non-root node.</span>
<span class="sd">        It is recommended to use the extension `.vnpkl` for this type of file.</span>

<span class="sd">        :param filepath: the file path for the pickle file. </span>
<span class="sd">            If `filepath=None` use `self._vnpkl_fpath` attribute, if set.</span>
<span class="sd">        :type filepath: str or None        </span>
<span class="sd">        :returns: `True` if successful. </span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">filepath</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_vnpkl_fpath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>
        <span class="c1"># if not _pfpath:</span>
        <span class="c1">#     logger.error(&quot;%s.save: «%s» file path «%s» not valid.&quot; % (self.__class__.__name__, self.name, _pfpath))</span>
        <span class="c1">#     return False</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vnpkl_fpath</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">pf</span><span class="p">:</span>
                <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_root</span><span class="o">.</span><span class="n">to_treedict</span><span class="p">(),</span> <span class="n">pf</span><span class="p">)</span> 
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.savefile: arg `filepath`=«</span><span class="si">%s</span><span class="s2">» `self._vnpkl_fpath`=«</span><span class="si">%s</span><span class="s2">» error: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">filepath</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vnpkl_fpath</span><span class="p">,</span> <span class="n">err</span><span class="p">))</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>       </div>


<div class="viewcode-block" id="Node.openfile"><a class="viewcode-back" href="../../api.html#vntree.Node.openfile">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">openfile</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">filepath</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Class method that opens (load) a vntree pickle file.</span>

<span class="sd">        :param filepath: the file path for the pickle file. </span>
<span class="sd">        :type filepath: str         </span>
<span class="sd">        :returns: root node of tree or `False` if failure. </span>
<span class="sd">        :rtype: Node or bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">filepath</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.openfile: arg `filepath`=«</span><span class="si">%s</span><span class="s2">» not valid.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">filepath</span><span class="p">))</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">pf</span><span class="p">:</span>
                <span class="n">pkldata</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">pf</span><span class="p">)</span>
            <span class="n">rootnode</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">treedict</span><span class="o">=</span><span class="n">pkldata</span><span class="p">)</span>
            <span class="n">rootnode</span><span class="o">.</span><span class="n">_vnpkl_fpath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.openfile: data in file «</span><span class="si">%s</span><span class="s2">» not valid: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">filepath</span><span class="p">,</span> <span class="n">err</span><span class="p">))</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">rootnode</span>            </div>


    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">setup_yaml</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">yamlnode_constructor</span><span class="p">(</span><span class="n">loader</span><span class="p">,</span> <span class="n">yamlnode</span><span class="p">)</span> <span class="p">:</span>
            <span class="n">fields</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">construct_mapping</span><span class="p">(</span><span class="n">yamlnode</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">return</span>  <span class="bp">cls</span><span class="p">(</span><span class="o">**</span><span class="n">fields</span><span class="p">)</span>
        <span class="n">yaml</span><span class="o">.</span><span class="n">SafeLoader</span><span class="o">.</span><span class="n">add_constructor</span><span class="p">(</span><span class="s1">&#39;!&#39;</span><span class="o">+</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">yamlnode_constructor</span><span class="p">)</span>
        <span class="c1"># def yamlnode_representer(dumper, data):</span>
        <span class="c1">#     rep = &#39;!Node&#39;</span>
        <span class="c1">#     return dumper.represent_scalar(&#39;!Node&#39;, &#39;%sd%s&#39; % data)</span>
        <span class="c1"># yaml.add_representer(cls, yamlnode_representer)</span>
       

<div class="viewcode-block" id="Node.yaml2tree"><a class="viewcode-back" href="../../api.html#vntree.Node.yaml2tree">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">yaml2tree</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">yamltree</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Class method that creates a tree from YAML.</span>

<span class="sd">        | # Example yamltree data:</span>
<span class="sd">        | - !Node &amp;root</span>
<span class="sd">        |   name: &quot;root node&quot;</span>
<span class="sd">        |   parent: null</span>
<span class="sd">        |   data:</span>
<span class="sd">        |     testpara: 111</span>
<span class="sd">        | - !Node &amp;child1</span>
<span class="sd">        |   name: &quot;child node&quot;</span>
<span class="sd">        |   parent: *root</span>
<span class="sd">        | - !Node &amp;gc1</span>
<span class="sd">        |   name: &quot;grand-child node&quot;</span>
<span class="sd">        |   parent: *child1</span>

<span class="sd">        :param yamltree: a string of YAML describing the nodes in the</span>
<span class="sd">            tree, or the path to a file containing the data.</span>
<span class="sd">        :type yamltree: str</span>
<span class="sd">        :returns: the root node of the tree. </span>
<span class="sd">        :rtype: Node </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">cls</span><span class="o">.</span><span class="n">YAML_setup</span><span class="p">:</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">setup_yaml</span><span class="p">()</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">YAML_setup</span> <span class="o">=</span> <span class="kc">True</span> 
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">yamltree</span><span class="p">):</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">yamltree</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
                <span class="n">yaml_data</span> <span class="o">=</span> <span class="n">fh</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">yaml_data</span> <span class="o">=</span> <span class="n">yamltree</span>
        <span class="n">list_of_nodes</span> <span class="o">=</span> <span class="n">yaml</span><span class="o">.</span><span class="n">safe_load</span><span class="p">(</span><span class="n">yaml_data</span><span class="p">)</span>
        <span class="n">yamltree_root</span> <span class="o">=</span> <span class="n">list_of_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">yamltree_root</span></div>


    <span class="k">def</span> <span class="nf">tree2yaml</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># if not self.__class__.YAML_setup:</span>
        <span class="c1">#     self.__class__.setup_yaml()</span>
        <span class="c1">#     self.__class__.YAML_setup = True </span>
        <span class="k">def</span> <span class="nf">make_anchor</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="c1"># if node._root is node:</span>
            <span class="c1">#     anchor = &quot;root&quot;</span>
            <span class="c1"># else:</span>
            <span class="n">anchor</span> <span class="o">=</span> <span class="s2">&quot;coord&quot;</span>
            <span class="k">for</span> <span class="n">_c</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">_coord</span><span class="p">:</span>
                <span class="n">anchor</span> <span class="o">+=</span> <span class="s2">&quot;-&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">_c</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">anchor</span>
        <span class="n">yltree</span> <span class="o">=</span> <span class="s2">&quot;# dummy </span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">for</span> <span class="n">_n</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">_ncopy</span> <span class="o">=</span> <span class="n">_n</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="nb">delattr</span><span class="p">(</span><span class="n">_ncopy</span><span class="p">,</span> <span class="s2">&quot;childs&quot;</span><span class="p">)</span>
            <span class="nb">delattr</span><span class="p">(</span><span class="n">_ncopy</span><span class="p">,</span> <span class="s2">&quot;parent&quot;</span><span class="p">)</span>
            <span class="c1"># if _n.parent:</span>
            <span class="c1">#     _ncopy.parent = &quot;*&quot; + make_anchor(_n.parent)</span>
            <span class="n">_yl</span> <span class="o">=</span> <span class="n">yaml</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">_ncopy</span><span class="p">,</span> <span class="n">default_flow_style</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">_n_yl</span> <span class="o">=</span> <span class="s1">&#39;!&#39;</span><span class="o">+</span><span class="n">_n</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>  <span class="o">+</span> <span class="s2">&quot; &amp;&quot;</span> <span class="o">+</span> <span class="n">make_anchor</span><span class="p">(</span><span class="n">_n</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">_n</span><span class="o">.</span><span class="n">parent</span><span class="p">:</span>
                <span class="n">_n_yl</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">parent: &quot;</span> <span class="o">+</span> <span class="s2">&quot;*&quot;</span> <span class="o">+</span> <span class="n">make_anchor</span><span class="p">(</span><span class="n">_n</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
            <span class="c1"># else:</span>
            <span class="c1">#     _n_yl += &quot;\n&quot;</span>
            <span class="n">_n_yl</span> <span class="o">+=</span> <span class="n">_yl</span><span class="p">[</span><span class="n">_yl</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">):]</span>
            <span class="n">yltree</span> <span class="o">+=</span> <span class="n">_n_yl</span>
        <span class="n">yltree</span> <span class="o">=</span> <span class="n">textwrap</span><span class="o">.</span><span class="n">indent</span><span class="p">(</span><span class="n">yltree</span><span class="p">,</span> <span class="s2">&quot;  &quot;</span><span class="p">)</span>
        <span class="n">yltree</span> <span class="o">=</span> <span class="n">yltree</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="n">yltree</span> <span class="o">=</span> <span class="n">yltree</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">  !&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">- !&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">yltree</span></div>



<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>
    <span class="n">ch</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">StreamHandler</span><span class="p">()</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">addHandler</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>

    <span class="n">SIMPLE_TREE</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="n">SIMPLE_TREE</span><span class="p">:</span>

        <span class="n">rootnode</span>   <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="s1">&#39;ROOT (level 0, the &quot;top&quot; of the tree)&#39;</span><span class="p">)</span>
        <span class="n">Node</span><span class="p">(</span><span class="s2">&quot;1st child (level 1, leaf node)&quot;</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="n">rootnode</span><span class="p">)</span>
        <span class="n">child2</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="s2">&quot;2nd child (level 1)&quot;</span><span class="p">,</span> <span class="n">rootnode</span><span class="p">)</span>
        <span class="n">Node</span><span class="p">(</span><span class="s2">&quot;grand-child1 (level 2, leaf node)&quot;</span><span class="p">,</span> <span class="n">child2</span><span class="p">)</span>
        <span class="n">Node</span><span class="p">(</span><span class="s2">&quot;grand-child2 (level 2, leaf node)&quot;</span><span class="p">,</span> <span class="n">child2</span><span class="p">)</span>
        <span class="n">child3</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="s2">&quot;3rd child (level 1)&quot;</span><span class="p">,</span> <span class="n">rootnode</span><span class="p">)</span>
        <span class="n">Node</span><span class="p">(</span><span class="s2">&quot;another child (level 1, leaf node)&quot;</span><span class="p">,</span> <span class="n">rootnode</span><span class="p">)</span>
        <span class="n">grandchild3</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">parent</span><span class="o">=</span><span class="n">child3</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;grand-child3 (level 2&quot;</span><span class="p">)</span>
        <span class="n">ggrandchild</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="s2">&quot;great-grandchild (level 3)&quot;</span><span class="p">,</span> <span class="n">grandchild3</span><span class="p">)</span>
        <span class="n">Node</span><span class="p">(</span><span class="s2">&quot;great-great-grandchild (level4, leaf node)&quot;</span><span class="p">,</span> <span class="n">ggrandchild</span><span class="p">)</span>
        <span class="n">Node</span><span class="p">(</span><span class="s2">&quot;great-grandchild2 (level 3, leaf node)&quot;</span><span class="p">,</span> <span class="n">grandchild3</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="n">rootnode</span><span class="o">.</span><span class="n">to_texttree</span><span class="p">())</span>
        <span class="c1"># for ii, node in enumerate(rootnode):</span>
        <span class="c1">#     print(&quot;{} top-down «{}»&quot;.format(ii, node.name))</span>
        <span class="c1"># for ii, node in enumerate(reversed(rootnode)):</span>
        <span class="c1">#     print(&quot;{} bottom-up «{}»&quot;.format(ii, node.name))</span>


</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><p class="logo"><a href="../../index.html">
<img class="logo" src="../../_static/logo.png" width="180" alt="Logo"/>
</a></p>
<form class="search" action="../../search.html" method="get">
  <input type="text" name="q"
   placeholder="type to search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
<script type="text/javascript">$('#searchbox').show(0);</script>
<h3><a href="../../index.html">Table of Contents</a></h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../user-guide.html">User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">API reference</a></li>
</ul>
<h3>Links</h3>
<ul>
  <li><a href="https://github.com/qwilka/vn-tree">vntree on GitHub</a></li>
  <li><a href="https://pypi.org/project/vntree">vntree on PyPI</a></li>
  <li><a href="https://qwilka.github.io/">Qwilka blog</a></li>
</ul>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
  <div class="related bottom">
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
  <nav id="breadcrumbs">
    <ul>
      <li><a href="../../index.html">vntree  documentation</a></li>
      <li>
        <a href="../index.html">Module code</a>
      </li> 
    </ul>
  </nav>
  </div>
  <footer id="pagefooter">&copy; 2019, Stephen McEntee.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a>
      2.1.2
        with the <a href="http://github.com/irskep/sphinx-better-theme">
          better</a> theme.

  </footer>

  
  </body>
</html>